<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最长有序子序列（递增）</title>
      <link href="/posts/9113.html"/>
      <url>/posts/9113.html</url>
      
        <content type="html"><![CDATA[<h3 id="首先我门要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出"><a href="#首先我门要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出" class="headerlink" title="首先我门要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出"></a>首先我门要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出</h3><h3 id="这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。"><a href="#这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。" class="headerlink" title="这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。"></a>这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。</h3><p>比如这个数组：1 4 7 2 5 8 3 6 9</p><h4 id="那dp数组就是：1-2-3-2-3-4-3-4-5"><a href="#那dp数组就是：1-2-3-2-3-4-3-4-5" class="headerlink" title="那dp数组就是：1 2 3 2 3 4 3 4 5"></a>那dp数组就是：1 2 3 2 3 4 3 4 5</h4><h4 id="怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度"><a href="#怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度" class="headerlink" title="怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度"></a>怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度</h4><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int num[1000];int dp[1000];int main()&#123;int n;cin&gt;&gt;n;for(int i&#x3D;0;i&lt;n;i++)&#123;cin&gt;&gt;num[i];&#125; dp[0]&#x3D;1;for(int i&#x3D;1;i&lt;n;i++)&#123;for(int j&#x3D;0;j&lt;i;j++)&#123;if(num[i]&gt;num[j])&#123;dp[i]&#x3D;max(dp[i],dp[j]);&#125;else&#123;continue;&#125;&#125; dp[i]+&#x3D;1;&#125;for(int i&#x3D;0;i&lt;n;i++)&#123;cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件监视</title>
      <link href="/posts/46616.html"/>
      <url>/posts/46616.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题链接：https-www-dotcpp-com-oj-problem2085-html"><a href="#问题链接：https-www-dotcpp-com-oj-problem2085-html" class="headerlink" title="问题链接：https://www.dotcpp.com/oj/problem2085.html"></a>问题链接：<a href="https://www.dotcpp.com/oj/problem2085.html">https://www.dotcpp.com/oj/problem2085.html</a></h3><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>作为一名网络警察，你的任务是监视电子邮件，看其中是否有一些敏感的关键词。不过，有些狡猾的犯罪嫌疑人会改变某些单词的字母顺序，以逃避检查。请编写一个程序，发现这种调整过顺序的关键词。程序的输入有两行，第一行是关键词列表，第二行是待检查的句子。程序的输出为在该句子中所找到的经过顺序调整的关键词。（单词全部为小写，单词之间以一个空格分隔，每一行的单词个数不限）</p><h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><h3 id="guns-mines-missiles"><a href="#guns-mines-missiles" class="headerlink" title="guns mines missiles"></a>guns mines missiles</h3><h3 id="aameric-ssell-snug-dan-iimsssle-ot-sit-neeemis"><a href="#aameric-ssell-snug-dan-iimsssle-ot-sit-neeemis" class="headerlink" title="aameric ssell snug dan iimsssle ot sit neeemis"></a>aameric ssell snug dan iimsssle ot sit neeemis</h3><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><h3 id="guns-missiles"><a href="#guns-missiles" class="headerlink" title="guns missiles"></a>guns missiles</h3><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>废物的我看到这题想着好麻烦，想着用for循环把每个字符串从输入提取出来然后再一一对比，感觉会死。但是我发现了大佬的写法，越发觉得stl真无敌，顺便学会了istringstream的用法。</p><h4 id="下面是istringstream用法的举例"><a href="#下面是istringstream用法的举例" class="headerlink" title="下面是istringstream用法的举例"></a>下面是istringstream用法的举例</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt; using namespace std;   int main()    &#123;      string str &#x3D; &quot;aa bb cc dd ee&quot;;      istringstream is(str);&#x2F;&#x2F;创建istringstream对象is     &#x2F;&#x2F;并同时使is和字符串str绑定     string s;       while (is &gt;&gt; s)&#x2F;&#x2F;将从str中读取到的字符串is写入到字符串s    &#123;          cout &lt;&lt; s &lt;&lt; endl;      &#125;        return 0; &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">输出如下:aamericssellsnugdaniimsssleotsitneeemis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好，接下来说思路，那有了istringstream这样的利器就好写了,拿两个字符串进行输入，然后再用vector存放提取出来的字符串，同时把每个字符串sort一下，这样比较就只要简单的==就行了。</p><h3 id="下面是源代码："><a href="#下面是源代码：" class="headerlink" title="下面是源代码："></a>下面是源代码：</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123;    string str1,str2;    getline(cin, str1);    getline(cin, str2);    vector&lt;string&gt;s1,s2,s3;    istringstream Str1(str1),Str2(str2);    string temp;    while(Str1&gt;&gt;temp) &#123;        s1.push_back(temp);        s2.push_back(temp);    &#125;    while (Str2&gt;&gt;temp) &#123;        s3.push_back(temp);    &#125;    for (int i &#x3D; 0; i &lt; s3.size(); i++) &#123;        sort(s3[i].begin(),s3[i].end());    &#125;    for (int i &#x3D; 0; i &lt; s3.size(); i++) &#123;        for (int j &#x3D; 0; j&lt;s2.size(); j++) &#123;            sort(s2[j].begin(),s2[j].end());if (s3[i] &#x3D;&#x3D; s2[j]) &#123;                cout &lt;&lt; s1[j] &lt;&lt;&quot; &quot;;                break;             &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费馅饼（dp入门）</title>
      <link href="/posts/20518.html"/>
      <url>/posts/20518.html</url>
      
        <content type="html"><![CDATA[<h2 id="免费馅饼"><a href="#免费馅饼" class="headerlink" title="免费馅饼"></a>免费馅饼</h2><p>问题描述：</p><h6 id="都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标："><a href="#都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：" class="headerlink" title="都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：          "></a>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：          <img src="1.png"></h6><h6 id="为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）"><a href="#为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）" class="headerlink" title="为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）"></a>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</h6><pre class="line-numbers language-none"><code class="language-none">Input输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n&#x3D;0时输入结束。Output每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Sample Input65 14 16 17 27 28 30Sample Output4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://vjudge.net/problem/HDU-1176">https://vjudge.net/problem/HDU-1176</a></p><h4 id="这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。"><a href="#这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。" class="headerlink" title="这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。"></a>这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。</h4><h4 id="下面是对样例的数组a-以及dp的展现"><a href="#下面是对样例的数组a-以及dp的展现" class="headerlink" title="下面是对样例的数组a,以及dp的展现"></a>下面是对样例的数组a,以及dp的展现</h4><pre class="line-numbers language-none"><code class="language-none">a[i][j]0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 1 1 1 0 0 00 0 0 0 0 0 0 0 2 0 00 0 0 0 0 0 0 0 0 1 0dp[i][j]0 0 0 0 1 1 4 4 4 3 30 0 0 0 0 1 1 4 3 3 10 0 0 0 0 0 0 0 3 1 10 0 0 0 0 0 0 0 0 1 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="由此得出状态转换方程dp-i-j-max-dp-i-1-j-1-max-dp-i-1-j-dp-i-1-j-1-a-i-j"><a href="#由此得出状态转换方程dp-i-j-max-dp-i-1-j-1-max-dp-i-1-j-dp-i-1-j-1-a-i-j" class="headerlink" title="由此得出状态转换方程dp[i][j]=max(dp[i+1][j-1], max(dp[i+1][j],dp[i+1][j+1]))+ a[i][j];"></a>由此得出状态转换方程dp[i][j]=max(dp[i+1][j-1], max(dp[i+1][j],dp[i+1][j+1]))+ a[i][j];</h4><h4 id="ps-位置从0开始不是很好处理，所以把每个位置就加一，从一开始"><a href="#ps-位置从0开始不是很好处理，所以把每个位置就加一，从一开始" class="headerlink" title="ps:位置从0开始不是很好处理，所以把每个位置就加一，从一开始"></a>ps:位置从0开始不是很好处理，所以把每个位置就加一，从一开始</h4><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int manx&#x3D;1e5+5;int dp[manx][15];&#x2F;&#x2F;num[a][b]代表第a秒在b位置上馅饼的数量 int a[manx][15];&#x2F;&#x2F;dp[a][b]代表第a秒在b位置上做多能有多少馅饼int n;int main()&#123;    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)    &#123;        if(!n) break;        memset(dp,0,sizeof(dp));        memset(a,0,sizeof(a));        int e&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;            int x,t;            scanf(&quot;%d%d&quot;,&amp;x,&amp;t);            a[t][++x]++;&#x2F;&#x2F;统计在b秒时位置x的馅饼数             e&#x3D;max(e,t);&#x2F;&#x2F;确定层数 &#125;        &#125;        for(int i&#x3D;e;i&gt;&#x3D;0;i--)        &#123;        for(int j&#x3D;1;j&lt;&#x3D;11;j++)        &#123;        dp[i][j]&#x3D;max(dp[i+1][j-1],                    max(dp[i+1][j],dp[i+1][j+1]))+                    a[i][j];&#125;&#125;        cout&lt;&lt;dp[0][6]&lt;&lt;endl;     &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走迷宫（bfs)</title>
      <link href="/posts/29413.html"/>
      <url>/posts/29413.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。</p><p>最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p><p>请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。</p><p>数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。</p><p>输入格式<br>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。</p><p>输出格式<br>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><p>数据范围<br>1≤n,m≤100</p><h1 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h1><h1 id="5-5"><a href="#5-5" class="headerlink" title="5 5"></a>5 5</h1><h1 id="0-1-0-0-0"><a href="#0-1-0-0-0" class="headerlink" title="0 1 0 0 0"></a>0 1 0 0 0</h1><h1 id="0-1-0-1-0"><a href="#0-1-0-1-0" class="headerlink" title="0 1 0 1 0"></a>0 1 0 1 0</h1><h1 id="0-0-0-0-0"><a href="#0-0-0-0-0" class="headerlink" title="0 0 0 0 0"></a>0 0 0 0 0</h1><h1 id="0-1-1-1-0"><a href="#0-1-1-1-0" class="headerlink" title="0 1 1 1 0"></a>0 1 1 1 0</h1><h1 id="0-0-0-1-0"><a href="#0-0-0-1-0" class="headerlink" title="0 0 0 1 0"></a>0 0 0 1 0</h1><h1 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h1><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,m;int dx[]&#x3D;&#123;0,0,-1,1&#125;;int dy[]&#x3D;&#123;-1,1,0,0&#125;;int mp[110][110];int vis[110][110];struct node&#123;    int x,y,step;&#125;;bool cheak(int x,int y)&#123;if(x&gt;&#x3D;1&amp;&amp;x&lt;&#x3D;n&amp;&amp;y&lt;&#x3D;m&amp;&amp;y&gt;&#x3D;1&amp;&amp;!vis[x][y]&amp;&amp;mp[x][y]!&#x3D;1)return true;else return false;&#125;void bfs()&#123;    queue&lt;node&gt;q;    node now,next;    now.x&#x3D;now.y&#x3D;1;now.step&#x3D;0;    vis[1][1]&#x3D;1;    q.push(now); while(!q.empty())&#123;    now&#x3D;q.front();q.pop();if(now.x&#x3D;&#x3D;n&amp;&amp;now.y&#x3D;&#x3D;m)&#123;     cout&lt;&lt;now.step&lt;&lt;endl; return;    &#125;for(int i&#x3D;0;i&lt;4;i++)&#123;    next.x&#x3D;now.x+dx[i];next.y&#x3D;now.y+dy[i];next.step&#x3D;now.step+1;if(cheak(next.x,next.y))&#123;vis[next.x][next.y]&#x3D;1;q.push(next);&#125;&#125;&#125; &#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )      &#123;          for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )          &#123;              cin &gt;&gt; mp[i][j];          &#125;      &#125;      bfs();      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="思路后续更新"><a href="#思路后续更新" class="headerlink" title="思路后续更新"></a>思路后续更新</h1>]]></content>
      
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪吃蛇</title>
      <link href="/posts/17402.html"/>
      <url>/posts/17402.html</url>
      
        <content type="html"><![CDATA[<h1 id="贪吃蛇c"><a href="#贪吃蛇c" class="headerlink" title="贪吃蛇c++"></a>贪吃蛇c++</h1><h1 id="注意需要安装easy库函数"><a href="#注意需要安装easy库函数" class="headerlink" title="注意需要安装easy库函数"></a><strong>注意需要安装easy库函数</strong></h1><h2 id="这是我第一次尝试做，可能比较拉（比如暂停功能有bug之-doge-，🐍有点简陋。。。）"><a href="#这是我第一次尝试做，可能比较拉（比如暂停功能有bug之-doge-，🐍有点简陋。。。）" class="headerlink" title="这是我第一次尝试做，可能比较拉（比如暂停功能有bug之[doge]，🐍有点简陋。。。）"></a><del>这是我第一次尝试做，可能比较拉（比如暂停功能有bug之[doge]，🐍有点简陋。。。）</del></h2><h3 id="下面是源代码"><a href="#下面是源代码" class="headerlink" title="下面是源代码"></a>下面是源代码</h3><pre class="line-numbers language-#include<stdio.h>" data-language="#include<stdio.h>"><code class="language-#include<stdio.h>">#include&lt;easyx.h&gt;#include &lt;conio.h&gt;&#x2F;&#x2F;按键操作#include&lt;stdlib.h&gt;#include&lt;graphics.h&gt;&#x2F;&#x2F;1.同下#include&lt;mmsyscom.h&gt;&#x2F;&#x2F;2.同下#pragma comment(lib,&quot;winmm.lib&quot;)&#x2F;&#x2F;3.多媒体#define Coords 500#define length 700#define high   500int cnt&#x3D;0;char num[20];bool isplay;enum DIR&#x2F;&#x2F;枚举，但不知道怎么用的&#123; up,   down,   left,   right,&#125;;struct snake&#x2F;&#x2F;蛇的结构&#123;  int size;&#x2F;&#x2F;蛇的字节  int dir;&#x2F;&#x2F;蛇的方向  int speed;&#x2F;&#x2F;移动速度  POINT coor[Coords];&#x2F;&#x2F;坐标&#125;snake;struct food&#123;int x;int y;int r;bool flag;&#x2F;&#x2F;判定是否被吃DWORD color;&#125;food;void loadrescource()&#123;IMAGE background;&#x2F;&#x2F;定义一个图片名.loadimage(&amp;background, &quot;.&#x2F;picture1&#x2F;true.jfif&quot;,700,500);&#x2F;&#x2F;从图片文件获取图像putimage(0, 0, &amp;background);&#x2F;&#x2F;绘制图像到屏幕，图片左上角坐标为(0,0)&#125;void gameinit()&#x2F;&#x2F;初始化&#123;isplay &#x3D; true;mciSendString(&quot;open .&#x2F;music&#x2F;7895.mp3 alias bgm&quot;, 0, 0, 0);mciSendString(&quot;play bgm repeat&quot;, 0, 0, 0);&#x2F;&#x2F;init初始化 graph 图形窗口initgraph(length,high);srand(GetTickCount());&#x2F;&#x2F;随机数种子&#x2F;&#x2F;设时间为随机数,获取系统开机到现在的毫秒数&#x2F;&#x2F;初始化蛇，一开始3节snake.size &#x3D; 3;     snake.speed &#x3D;5;snake.dir&#x3D;right;&#x2F;&#x2F;方向for (int i &#x3D; 0; i &lt;snake.size; i++) &#123;snake.coor[i].x &#x3D; 70-15*i;    snake.coor[i].y &#x3D; 10;&#125;&#x2F;&#x2F;初始化食物food.x &#x3D; rand() % (length-100)+25;&#x2F;&#x2F;随机产生一个整数的函数，需要随机数种子food.y &#x3D; rand() % (high - 100)+25;food.color &#x3D; RGB(rand()%256,rand()%256,rand()%256);food.r &#x3D; rand() % 10 +10;food.flag &#x3D; true;&#125;void gamedraw()&#x2F;&#x2F;绘制蛇&#123;&#x2F;&#x2F;sprintf(Time,&quot;%d&quot;,pp);BeginBatchDraw();&#x2F;&#x2F;双缓存&#x2F;&#x2F;setbkcolor(RGB(28, 115, 119));cleardevice();&#x2F;&#x2F;清空绘图设备loadrescource();outtextxy(610, 10, &quot;分数:&quot;);outtextxy(650, 10, num);outtextxy(540, 10, &quot;音乐:&quot;);if (isplay)&#123;         outtextxy(585, 10, &quot;开&quot;);&#125;else&#123;outtextxy(585, 10, &quot;关&quot;);&#125;setfillcolor(BLUE);&#x2F;&#x2F;设置蛇身颜色为蓝色for (int i &#x3D; 1; i &lt;snake.size; i++) &#123;solidcircle(snake.coor[i].x, snake.coor[i].y, 6);&#x2F;&#x2F;x轴，y轴，半径&#125;setfillcolor(RED);&#x2F;&#x2F;设置蛇头颜色为红色solidcircle(snake.coor[0].x, snake.coor[0].y, 6);if (food.flag&#x3D;&#x3D;true)&#123;solidcircle(food.x, food.y, food.r);&#125;EndBatchDraw();&#125;void snakemove() &#123;&#x2F;&#x2F;移动蛇for (int i &#x3D; snake.size-1; i &gt;0; i--)&#x2F;&#x2F;后面到前面依次向前走&#123;snake.coor[i]&#x3D;snake.coor[i - 1]; &#125;switch (snake.dir)&#123;case up:&#x2F;&#x2F;进行方向改变snake.coor[0].y-&#x3D;snake.speed;if (snake.coor[0].y +6&lt;&#x3D; 0) &#123;snake.coor[0].y &#x3D; high;&#125;break;case down:&#x2F;&#x2F;同上snake.coor[0].y+&#x3D;snake.speed;if (snake.coor[0].y + 6 &gt;&#x3D; high)&#123;snake.coor[0].y &#x3D; 0;&#125;break;case left:&#x2F;&#x2F;同上snake.coor[0].x-&#x3D;snake.speed;if (snake.coor[0].x + 6 &lt;&#x3D; 0)&#123;snake.coor[0].x &#x3D; length;&#125;break;case right:&#x2F;&#x2F;同上snake.coor[0].x+&#x3D;snake.speed;if (snake.coor[0].x+ 6 &gt;&#x3D;length)&#123;snake.coor[0].x &#x3D; 0;&#125;break;&#125;&#125;void keycontrol()&#123;&#x2F;&#x2F;通过按键进行控制if (_kbhit())&#x2F;&#x2F;判断有没有按键，如果有就为真&#123;    switch (_getch())  &#123;&#x2F;&#x2F;72 80 75 77 上下左右键值 case &#39;w&#39;:case &#39;W&#39;:case 72:if (snake.dir !&#x3D; down) &#123;                     snake.dir &#x3D; up;&#125;&#x2F;&#x2F;改变方向break;case &#39;s&#39;:case &#39;S&#39;:case 80:if (snake.dir !&#x3D; up)&#123;   snake.dir &#x3D; down;&#125;break;case &#39;a&#39;:case &#39;A&#39;:case 75:if (snake.dir !&#x3D; right)&#123;snake.dir &#x3D; left;&#125;break;case &#39;d&#39;:case &#39;D&#39;:case 77:if (snake.dir !&#x3D; left)&#123;snake.dir &#x3D; right;&#125;break;case &#39; &#39;:   &#x2F;&#x2F;按空格暂停if (isplay)&#123;mciSendString(&quot;pause  bgm&quot;, 0, 0, 0);isplay &#x3D; !isplay;outtextxy(585, 10, &quot;关&quot;);&#125;else&#123;mciSendString(&quot;play  bgm repeat&quot;, 0, 0, 0);isplay &#x3D; !isplay;outtextxy(585, 10, &quot;开&quot;);&#125;while (1)&#123;if (_getch() &#x3D;&#x3D; &#39; &#39;)&#123;outtextxy(585, 10, &quot;开&quot;);return;&#125;&#125;     &#125;&#125;&#125;void eatfood()&#123;sprintf(num,&quot;%d&quot;,cnt);if (food.flag &#x3D;&#x3D; true &amp;&amp; snake.coor[0].x &gt;&#x3D; food.x - food.r &amp;&amp; snake.coor[0].x &lt;&#x3D; food.x + food.r&amp;&amp; snake.coor[0].y &gt;&#x3D; food.y - food.r &amp;&amp; snake.coor[0].y &lt;&#x3D; food.y + food.r)&#123;&#x2F;&#x2F;判断吃到食物food.flag &#x3D; false;snake.size++;&#x2F;&#x2F;snake.speed++;if (food.r&gt;&#x3D;8)&#123;        cnt+&#x3D;1;&#125;else if (food.r &lt; 8)&#123;cnt +&#x3D; 2;&#125;&#125;if (food.flag &#x3D;&#x3D; false)&#x2F;&#x2F;刷新食物&#123;food.x &#x3D; rand() % length;&#x2F;&#x2F;随机产生一个整数的函数，需要随机数种子food.y &#x3D; rand() % high;food.color &#x3D; RGB(rand() % 256, rand() % 256, rand() % 256);food.r &#x3D; rand() % 10 + 5;food.flag &#x3D; true;&#125;&#125;void cheak()&#x2F;&#x2F;吃到自己死亡&#123;for (int i &#x3D; 1; i &lt; snake.size; i++)&#123;if (snake.coor[0].x &#x3D;&#x3D; snake.coor[i].x &amp;&amp;snake.coor[0].y &#x3D;&#x3D; snake.coor[i].y)&#123;gameinit();cnt &#x3D; 0;&#125;&#125;&#125;int main()&#123;gameinit();while (1) &#123;   gamedraw();  snakemove();  keycontrol();  eatfood();  Sleep(20);&#x2F;&#x2F;延迟20毫秒  cheak();&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="到此为止，感想大家观看"><a href="#到此为止，感想大家观看" class="headerlink" title="到此为止，感想大家观看"></a>到此为止，感想大家观看</h2><h2 id="ps-刚搭的博客，还没搞好，先凑合用"><a href="#ps-刚搭的博客，还没搞好，先凑合用" class="headerlink" title="ps:刚搭的博客，还没搞好，先凑合用"></a><del>ps:刚搭的博客，还没搞好，先凑合用</del></h2><p>此代码仅供参考，帮助大家理解。（毕竟我自己开始弄的时候什么都看不懂，花了好久才会的，希望这个能帮助大家）</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
