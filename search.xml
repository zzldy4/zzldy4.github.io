<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>01背包</title>
      <link href="/posts/25ef.html"/>
      <url>/posts/25ef.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接：2-01背包问题-AcWing题库"><a href="#题目链接：2-01背包问题-AcWing题库" class="headerlink" title="题目链接：2. 01背包问题 - AcWing题库"></a>题目链接：<a href="https://www.acwing.com/problem/content/description/2/">2. 01背包问题 - AcWing题库</a></h3><h2 id="首先是经典做法："><a href="#首先是经典做法：" class="headerlink" title="首先是经典做法："></a>首先是经典做法：</h2><p>定义  dp[i][j]:代表前i个物体在j空间下价值最大是多少</p><p>然后我们要知道当前的状态依赖于之前的状态，可以理解为从初始状态dp[1][0] = 0开始决策，那么到了dp[1][1]就有两种选择，在当前空间够的情况下比较放入该物体后的价值与不放入该物体的价值，而如果空间不够，就保持之前状态不变。所以递推式就是</p><p><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</code></p><h3 id="下面是代码实现："><a href="#下面是代码实现：" class="headerlink" title="下面是代码实现："></a>下面是代码实现：</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits/stdc++.h&gt;using namespace std;int w[1010],v[1010];int dp[1010][1010];int main(){    int m,n;    cin&gt;&gt;n&gt;&gt;m;//n为物品数量    m为背包容积。    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;w[i];//重量         cin&gt;&gt;v[i];//价值     }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            if(j&lt;w[i]){//当前物体体积超出背包体积                dp[i][j]=dp[i-1][j];            }            //可以放入，比较放入与不放哪个更优            else{                dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);            }        }    }    cout&lt;&lt;dp[n][m]&lt;&lt;endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="然后我们进行优化：使用滚动数组"><a href="#然后我们进行优化：使用滚动数组" class="headerlink" title="然后我们进行优化：使用滚动数组"></a>然后我们进行优化：使用滚动数组</h2><p>根据上面的递推式我们能发现dp[i][j]的值要么保持不变，要么就是根据dp[i-1][j-w[i]]与dp[i-1][j]的比较进行改变。也就是说 dp 数组中第i行的元素仅由第 i−1 行的元素得来，即第 0 行元素的更新值放到第 1 行，第 1 行元素的更新值放到第 2 行，以此类推。与其把一行的更新值放到新的一行，不如直接就地更新，因此我们的 dp 数组只需要一行来存储，即一维数组。</p><h4 id="那么递推式就是-dp-j-max-dp-j-dp-j−w-i-v-i"><a href="#那么递推式就是-dp-j-max-dp-j-dp-j−w-i-v-i" class="headerlink" title="那么递推式就是 dp[j]=max(dp[j],dp[j−w[i]]+v[i])"></a>那么递推式就是 dp[j]=max(dp[j],dp[j−w[i]]+v[i])</h4><p>但是这样做还有个问题，那就是j的遍历得改成倒序。首先我们要明白一维数组dp[j]其实就相当与dp[n][j]，所以dp[j]就应该代表当前空间下放入所有物体的最优解。而在原本递推式中一维的dp[j-1]其实应该代表dp[i-1][j-1],但是顺序遍历会直接将dp[j-1]直接更新为dp[i][j-1]，所以应该倒过来，这样才能保证前面的数是当前数的上一层。</p><h2 id="下面是优化后代码"><a href="#下面是优化后代码" class="headerlink" title="下面是优化后代码"></a>下面是优化后代码</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits/stdc++.h&gt;using namespace std;int w[1010],v[1010];int dp[1010];int main(){    int m,n;    cin&gt;&gt;n&gt;&gt;m;//n为物品数量    m为背包容积。    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;v[i];//体积         cin&gt;&gt;w[i];//价值     }    for(int i=1;i&lt;=n;i++){//这里的i其实可以理解为dp[i][j]中的i，这样更好理解当前层与上一层    for(int j=m;j&gt;=v[i];j--){ dp[j]=max(dp[j],dp[j-v[i]]+w[i]);    }}      cout&lt;&lt;dp[m]&lt;&lt;endl;      return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="当然还可以在优化一点点，那就是在输入上优化。"><a href="#当然还可以在优化一点点，那就是在输入上优化。" class="headerlink" title="当然还可以在优化一点点，那就是在输入上优化。"></a>当然还可以在优化一点点，那就是在输入上优化。</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1005;int dp[MAXN];  // int main() {    int n, m;       cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) {        int v, w;        cin &gt;&gt; v &gt;&gt; w;      // 边输入边处理        for(int j = m; j &gt;= v; j--)            dp[j] = max(f[j], f[j - v] + w);    }    cout &lt;&lt; dp[m] &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树构建</title>
      <link href="/posts/5a09b4da.html"/>
      <url>/posts/5a09b4da.html</url>
      
        <content type="html"><![CDATA[<h2 id="首先我们要知道二叉树常用到的遍历有这三种"><a href="#首先我们要知道二叉树常用到的遍历有这三种" class="headerlink" title="首先我们要知道二叉树常用到的遍历有这三种"></a>首先我们要知道二叉树常用到的遍历有这三种</h2><p><strong>先序遍历：*<em>先遍历根节点，然后再分别遍历左节点和右节点。(根左右)*</em></strong></p><p><strong>中序遍历：*<em>先遍历左节点，然后再遍历根节点，最后遍历右节点。(左根右)*</em></strong></p><p><strong>后序遍历：*<em>先遍历左节点，然后再遍历右节点，最后遍历根节点。（左右根）*</em></strong></p><p>如下图所示</p><p><img src="/posts/5a09b4da/1.png" alt="error"></p><h3 id="按照中序遍历的打印顺序为：D-B-E-A-F-C-G"><a href="#按照中序遍历的打印顺序为：D-B-E-A-F-C-G" class="headerlink" title="按照中序遍历的打印顺序为：D　B　E　A　F　C　G"></a>按照<a href="https://so.csdn.net/so/search?q=%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86&amp;spm=1001.2101.3001.7020">中序遍历</a>的打印顺序为：D　B　E　A　F　C　G</h3><h3 id="按照先序遍历的打印顺序为：A-B-D-E-C-F-G"><a href="#按照先序遍历的打印顺序为：A-B-D-E-C-F-G" class="headerlink" title="按照先序遍历的打印顺序为：A　B　D　E　C　F　G"></a>按照<a href="https://so.csdn.net/so/search?q=%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86&amp;spm=1001.2101.3001.7020">先序遍历</a>的打印顺序为：A　B　D　E　C　F　G</h3><h3 id="按照后序遍历的打印顺序为：D-E-B-F-G-C-A"><a href="#按照后序遍历的打印顺序为：D-E-B-F-G-C-A" class="headerlink" title="按照后序遍历的打印顺序为：D　E　B 　F   G    C   A"></a>按照后序遍历的打印顺序为：D　E　B 　F   G    C   A</h3><p> 我们首先应该知道只有一种遍历序列是无法得出二叉树的树形的。因为不同的二叉树可能有一个相同的先序序列、中序序列、和后序序列。但是一棵二叉树有唯一的三个先序序列、中序序列、和后序序列</p><p>有数学证明（反正我看不懂）</p><p><img src="/posts/5a09b4da/6.jpg"></p><p><img src="/posts/5a09b4da/7.jpg"></p><p>那么接下来我们就要研究如何由前序遍历序列和中序遍历序列构造二叉树</p><p><u>ps（其实只要同时知道两种序列就能确定二叉树了）</u></p><table><thead><tr><th>先序</th><th>ABCDE</th></tr></thead><tbody><tr><td>中序</td><td>CDBAE</td></tr></tbody></table><p>那根据先序遍历我们就能知道根节点就是A，又通过中序节点能得知CDB为A的左子树中的节点，E为右子树的节点</p><p><img src="/posts/5a09b4da/2.png"></p><p>然后以B为根节点，又通过中序节点得知CD为B的左子树的节点，无右子树。</p><p><img src="/posts/5a09b4da/3.png"></p><p>以此类推，C为根节点，无左子树，D为右子树</p><p><img src="/posts/5a09b4da/4.png"></p><p>创建后二叉树如下</p><p><img src="/posts/5a09b4da/5.png"></p><p>以上图片引用:<a href="https://blog.csdn.net/Nan_Feng726/article/details/91049122">https://blog.csdn.net/Nan_Feng726/article/details/91049122</a></p><p>下面是代码，主要是通过递归实现</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct TNode{char data;struct TNode* left;struct TNode* right;};TNode* InPreToTree(char *pa, char *ia, int p1, int p2, int i1, int i2)//返回树的根节点{TNode* root =  new TNode;if(p1&gt;p2)return NULL; //该节点不存在    root-&gt;data=pa[p1];int i = 0;               printf("%c\n",pa[p1]);while (ia[i] != pa[p1])i++;//在中序中找到根节点所在的下标int llen = i - i1;//得出左节点数量int rlen = i2 - i;//得出右节点数量if (i1 &gt;= i2) {//不存在左右子树root-&gt;left = root-&gt;right = NULL;    }else {//切出左子树的前序和中序root-&gt;left = InPreToTree(pa, ia, p1 + 1, p1+ llen, i1, i1+ llen-1);//切出右子树的前序和中序    root-&gt;right= InPreToTree(pa, ia, p2 - rlen + 1, p2, i2- rlen+ 1, i2);           }return root;} void PrintPostTravel(TNode* t){if(t==NULL) return;if(t-&gt;left) PrintPostTravel(t-&gt;left);if(t-&gt;right) PrintPostTravel(t-&gt;right);printf("%c", t-&gt;data);}void DeleteTree(TNode* t){if(t==NULL) return;if(t-&gt;left) DeleteTree(t-&gt;left);if(t-&gt;right) DeleteTree(t-&gt;right);delete t;}int main(){char pre[100], in[100];int n; //用来保存序列长度TNode *t;//用来保存二叉树的根scanf("%s", pre);scanf("%s", in);n=0; while(pre[n]) n++;t= InPreToTree(pre, in, 0, n-1, 0, n-1);             PrintPostTravel(t);printf("\n");DeleteTree(t);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算器组成实验</title>
      <link href="/posts/1dd4624d.html"/>
      <url>/posts/1dd4624d.html</url>
      
        <content type="html"><![CDATA[<p>这个实验是关于计算器的组成，实验平台是Quartus II<br>主要是分别构建计算器和存储器然后通过数据通路相连</p><p>首先是实验原理图：</p><p><img src="/posts/1dd4624d/3.PNG"></p><p><img src="/posts/1dd4624d/2.PNG"></p><p>然后跟据上表原理中真值表写下面alu(计算器)的实验代码，语言是vhdl</p><pre class="line-numbers language-none"><code class="language-none">library ieee;use ieee.std_logic_1164.all;use ieee.std_logic_unsigned.all;entity exp_r_alu isport(clk                          :in std_logic;sw_bus,r4_bus,r5_bus,alu_bus :in std_logic;lddr1,lddr2,ldr4,ldr5        :in std_logic;m,cn                         :in std_logic;s                            :in std_logic_vector(3 downto 0);k                            :in std_logic_vector(7 downto 0);d                            :inout std_logic_vector(7 downto 0) );end exp_r_alu;architecture rtl of exp_r_alu issignal dr1,dr2,r4,r5,aluout,bus_reg:std_logic_vector(7 downto 0);signal sel:std_logic_vector(5 downto 0);beginldreg:process(clk,lddr1,lddr2,ldr4,ldr5,bus_reg)beginif clk'event and clk='1' thenif lddr1='1' then dr1&lt;=bus_reg;    elsif lddr2='1' then dr2&lt;=bus_reg;    elsif ldr4='1' then r4&lt;=bus_reg;    elsif ldr5='1' then r5&lt;=bus_reg;    end if;end if;end process;alu:process(m,cn,s,dr1,dr2,sel,aluout)   begin   sel&lt;=m &amp; cn &amp; s;   case sel iswhen "000000" =&gt; aluout&lt;=dr1+1;when "010000" =&gt; aluout&lt;=dr1;when "100000" =&gt; aluout&lt;=not dr1;when "000001" =&gt; aluout&lt;=(dr1 or dr2)+1;when "010001" =&gt; aluout&lt;=dr1 or dr2;when "100001" =&gt; aluout&lt;=not(dr1 or dr2);when "000010" =&gt; aluout&lt;=(dr1 or (not dr2))+1;when "010010" =&gt; aluout&lt;=dr1 or (not dr2);when "100010" =&gt; aluout&lt;=(not dr1)and dr2;when "000011" =&gt; aluout&lt;=x"00";when "010011" =&gt; aluout&lt;=aluout-1;when "100011" =&gt; aluout&lt;=x"00";when "000100" =&gt; aluout&lt;=dr1+(dr1 and (not dr2))+1;when "010100" =&gt; aluout&lt;=dr1+(dr1 and (not dr2));when "100100" =&gt; aluout&lt;=not (dr1 and dr2);when "000101" =&gt; aluout&lt;=((dr1 or dr2 or dr1) and dr2) or x"01";when "010101" =&gt; aluout&lt;=(dr1 or dr2)+(dr1 and(not dr2));when "100101" =&gt; aluout&lt;=not dr2;when "000110" =&gt; aluout&lt;=dr1-dr2;when "010110" =&gt; aluout&lt;=dr1-dr2-1;when "100110" =&gt; aluout&lt;=dr1 xor dr2;when "000111" =&gt; aluout&lt;=dr1 and(not dr2);when "010111" =&gt; aluout&lt;=(dr1 and (not dr2))-1;when "100111" =&gt; aluout&lt;=dr1 and(not dr2);when "001000" =&gt; aluout&lt;=dr1+(dr1 and dr2)+1;when "011000" =&gt; aluout&lt;=dr1+(dr1 and dr2);when "101000" =&gt; aluout&lt;=(not dr1)or dr2;when "001001" =&gt; aluout&lt;=dr1+dr2+1;when "011001" =&gt; aluout&lt;=dr1+dr2;  when "101001" =&gt; aluout&lt;=dr1 xnor dr2;when "001010" =&gt; aluout&lt;=(dr1 or(not dr2))+(dr1 and dr2)+1;when "011010" =&gt; aluout&lt;=(dr1 or(not dr2))+(dr1 and dr2);when "101010" =&gt; aluout&lt;=dr2;when "001011" =&gt; aluout&lt;=dr1 and dr2;when "011011" =&gt; aluout&lt;=(dr1 and dr2)-1;when "101011" =&gt; aluout&lt;=dr1 and dr2;when "001100" =&gt; aluout&lt;=dr1+dr1+1;when "011100" =&gt; aluout&lt;=dr1 or dr1;when "101100" =&gt; aluout&lt;=x"01";when "001101" =&gt; aluout&lt;=(dr1 or dr2)+dr1+1;when "011101" =&gt; aluout&lt;=(dr1 or dr2)+dr1;when "101101" =&gt; aluout&lt;=dr1 or(not dr2);when "001110" =&gt; aluout&lt;=(dr1 or (not dr2))+dr1+1;when "011110" =&gt; aluout&lt;=(dr1 or (not dr2))+dr1;when "101110" =&gt; aluout&lt;=dr1 or dr2;when "001111" =&gt; aluout&lt;=dr1;when "011111" =&gt; aluout&lt;=dr1-1;when "101111" =&gt; aluout&lt;=dr1;when others   =&gt; aluout&lt;=x"ff";end case;end process;bus_reg&lt;=k     when sw_bus='0'  else r4     when r4_bus='0'  else r5     when r5_bus='0'  else aluout  when alu_bus='0' else d;d&lt;=bus_reg when (sw_bus='0' or r4_bus='0' or r5_bus='0' or alu_bus='0') else   (others=&gt;'Z');end rtl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是波形仿真图，结果如下</p><p><img src="/posts/1dd4624d/1.PNG"></p><p>k:是输入的数</p><p>ldr1/r2/r4/r5:代表选择存入哪个寄存器。（高电位有效）</p><p>sw_/r4/r5/alu:代表选择哪个进行输入（低电平有效，sw_代表数据总线输入数据也就是输入k的数）</p><p>m/cn/s:m代表是否进行逻辑计算，cn代表是否进行进位计算，m代表哪个模式（模式看74181模式图）</p><p>dr1:表示r1寄存器的数</p><p>dr2:表示r2寄存器的数</p><p>r4:表示r4寄存器的数</p><p>r5:表示r5寄存器的数</p><p>d`result:表示输出的数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据溢出</title>
      <link href="/posts/43290.html"/>
      <url>/posts/43290.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){   short s1=32767,s2=-32768,s; //-32768为16位最小负数，32767为16位最大正数    unsigned char uc1=128,uc2=255,uc;//255为8位无符号最大值    s=s1+1;   printf("%d+1=%d\n",s1,s);// 输出32767+1=-32768   s=s2-3;   printf("%d-3=%d\n",s2,s);//输出-32768-3=32765   uc=uc1+uc2;   printf("%d+%d=%d\n",uc1,uc2,uc);//输出128+255=127   uc=uc1-uc2;   printf("%d-%d=%d\n",uc1,uc2,uc);//输出128-255=129      int p=pow(2,31);//应该是p=2147483648   printf("2^31=%d\n",p);//程序计算出是p=2147483647   p=p+1;   printf("2^31+1=%d\n",p);//p=-2147483648   p=p+1;   printf("2^31+1+1%d\n",p);//p=-2147483647  return 0;}/*     111 1111 1111 1111 1111 1111 1111 1111   2^31-1=2,147,483,647  1000 0000 0000 0000 0000 0000 0000 0000   2^31  =2,147,483,6481 0000 0000 0000 0000 0000 0000 0000 0000   2^32*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是实验代码。</p><p>原理如下，数据类型在计算机中的储存方式是二进制，且用补码表示</p><p><img src="/posts/43290/1.jpg"></p><p>ps(有符号数第一位是符号位，0为正数，1为负数)</p><p>以四位数的上溢举例：</p><table><thead><tr><th>无符号数</th><th>有符号数</th></tr></thead><tbody><tr><td>1111</td><td>0111</td></tr><tr><td>+0001</td><td>+0001</td></tr><tr><td>10000</td><td>1000</td></tr></tbody></table><p>由于是四位，所以只能保留后四位，所以第一个结果为0，第二个因为第一位为1，所以是-8。</p><p>下面是下溢：</p><table><thead><tr><th>无符号数</th><th>有符号数</th></tr></thead><tbody><tr><td>0000</td><td>1000</td></tr><tr><td>-0001</td><td>-0001</td></tr><tr><td>1111</td><td>0111</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros学习日记（2）</title>
      <link href="/posts/13787.html"/>
      <url>/posts/13787.html</url>
      
        <content type="html"><![CDATA[<h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><pre class="line-numbers language-none"><code class="language-none">  ros::init(argc, argv, "velocity_publisher");初始化节点ros::NodeHandle  n;//节点句柄ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;("/turtle1/cmd_vel", 10);// 定义名为turtle_vel_pub的Publisher名为turtle1/cmd_vel的topic消息类型Ϊgeometry_msgs::Twist队列长10ros::Rate loop_rate(10);//循环频率int count = 0;while (ros::ok())判断是否存在节点{      // 定义名为vel_msg类型为geometry_msgs::Twist的消息geometry_msgs::Twist vel_msg;vel_msg.linear.x = 0.5;//???????vel_msg.angular.z = 0.2;//???????  //发送消息turtle_vel_pub.publish(vel_msg);ROS_INFO("Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]", vel_msg.linear.x, vel_msg.angular.z);    //按照循环频率延时    loop_rate.sleep();}return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros学习笔记（1）</title>
      <link href="/posts/3793.html"/>
      <url>/posts/3793.html</url>
      
        <content type="html"><![CDATA[<h1 id="ros信方式：话题通信和服务通信。"><a href="#ros信方式：话题通信和服务通信。" class="headerlink" title="ros信方式：话题通信和服务通信。"></a>ros信方式：话题通信和服务通信。</h1><h2 id="话题通信："><a href="#话题通信：" class="headerlink" title="话题通信："></a>话题通信：</h2><h3 id="话题：（topic-–异步通信机制。节点间用来传输数据的总线；使用发布订阅模型。ps-同一个话题的订阅者或发布者可以不唯一"><a href="#话题：（topic-–异步通信机制。节点间用来传输数据的总线；使用发布订阅模型。ps-同一个话题的订阅者或发布者可以不唯一" class="headerlink" title="话题：（topic)–异步通信机制。节点间用来传输数据的总线；使用发布订阅模型。ps:同一个话题的订阅者或发布者可以不唯一"></a>话题：（topic)–异步通信机制。节点间用来传输数据的总线；使用发布订阅模型。ps:同一个话题的订阅者或发布者可以不唯一</h3><h3 id="消息：（Message-–话题数据。使用编程语言无关的-msg文件，编译过程中生存对应的代码文件。"><a href="#消息：（Message-–话题数据。使用编程语言无关的-msg文件，编译过程中生存对应的代码文件。" class="headerlink" title="消息：（Message)–话题数据。使用编程语言无关的.msg文件，编译过程中生存对应的代码文件。"></a>消息：（Message)–话题数据。使用编程语言无关的.msg文件，编译过程中生存对应的代码文件。</h3><h2 id="服务通信："><a href="#服务通信：" class="headerlink" title="服务通信："></a>服务通信：</h2><h3 id="服务：使用客户端、服务器（c-s-模型。使用编程语言无关的-srv文件定义请求和应答数据结构。"><a href="#服务：使用客户端、服务器（c-s-模型。使用编程语言无关的-srv文件定义请求和应答数据结构。" class="headerlink" title="服务：使用客户端、服务器（c/s)模型。使用编程语言无关的.srv文件定义请求和应答数据结构。"></a>服务：使用客户端、服务器（c/s)模型。使用编程语言无关的.srv文件定义请求和应答数据结构。</h3><h2 id="两者对比：（第一个是话题，第二个服务）"><a href="#两者对比：（第一个是话题，第二个服务）" class="headerlink" title="两者对比：（第一个是话题，第二个服务）"></a>两者对比：（第一个是话题，第二个服务）</h2><h3 id="1）同步性：异步，同步。"><a href="#1）同步性：异步，同步。" class="headerlink" title="1）同步性：异步，同步。"></a>1）同步性：异步，同步。</h3><h3 id="2）底层协议：rostcp-rosudp"><a href="#2）底层协议：rostcp-rosudp" class="headerlink" title="2）底层协议：rostcp/rosudp"></a>2）底层协议：rostcp/rosudp</h3><h3 id="3）反馈机制：无，有"><a href="#3）反馈机制：无，有" class="headerlink" title="3）反馈机制：无，有."></a>3）反馈机制：无，有.</h3><h3 id="4）缓冲区：有，无"><a href="#4）缓冲区：有，无" class="headerlink" title="4）缓冲区：有，无"></a>4）缓冲区：有，无</h3><h3 id="5）实时性：弱，强"><a href="#5）实时性：弱，强" class="headerlink" title="5）实时性：弱，强"></a>5）实时性：弱，强</h3><h3 id="6）节点关系：多对多，一对多"><a href="#6）节点关系：多对多，一对多" class="headerlink" title="6）节点关系：多对多，一对多"></a>6）节点关系：多对多，一对多</h3><h3 id="7）适用场景：数据传输，逻辑处理"><a href="#7）适用场景：数据传输，逻辑处理" class="headerlink" title="7）适用场景：数据传输，逻辑处理"></a>7）适用场景：数据传输，逻辑处理</h3>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长有序子序列（递增）</title>
      <link href="/posts/9113.html"/>
      <url>/posts/9113.html</url>
      
        <content type="html"><![CDATA[<h3 id="首先我们要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出"><a href="#首先我们要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出" class="headerlink" title="首先我们要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出"></a>首先我们要知道什么是子序列，子序列就是从原来的数列中选出一部分顺序不变的数列，那理解了什么是子序列我们接下来就是解决如何找出</h3><h3 id="这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。"><a href="#这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。" class="headerlink" title="这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。"></a>这道题是dp中的基础题，那我们应该怎么进行思考呢，我们应该知道dp其实就是把问题分解，（我个人觉得就是从结果出发然后倒推）就比如这个，假设我们得到一个子序列，那这个子序列就一定会有一个结尾，而我们要做的就是枚举数组中的每个数字作为子序列的结尾，然后得出该子序列的长度。</h3><h4 id="比如这个数组：1-4-7-2-5-8-3-6-9"><a href="#比如这个数组：1-4-7-2-5-8-3-6-9" class="headerlink" title="比如这个数组：1 4 7 2 5 8 3 6 9"></a>比如这个数组：1 4 7 2 5 8 3 6 9</h4><h4 id="那dp数组就是：1-2-3-2-3-4-3-4-5"><a href="#那dp数组就是：1-2-3-2-3-4-3-4-5" class="headerlink" title="那dp数组就是：1 2 3 2 3 4 3 4 5"></a>那dp数组就是：1 2 3 2 3 4 3 4 5</h4><h4 id="怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度"><a href="#怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度" class="headerlink" title="怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度"></a>怎么来的呢，首先我们以1作为结尾，那长度就是1，然后是4作为结尾，那它的长度就是自身加上以1结尾的子序列的长度。一般情况就是找出前面用比自己小的数字作为结尾的子序列的最大长度</h4><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits/stdc++.h&gt;using namespace std;int num[1000];int dp[1000];int main(){int n;cin&gt;&gt;n;for(int i=0;i&lt;n;i++){cin&gt;&gt;num[i];} dp[0]=1;for(int i=1;i&lt;n;i++){for(int j=0;j&lt;i;j++){if(num[i]&gt;num[j]){dp[i]=max(dp[i],dp[j]);}else{continue;}} dp[i]+=1;}for(int i=0;i&lt;n;i++){cout&lt;&lt;dp[i]&lt;&lt;" ";}} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件监视</title>
      <link href="/posts/46616.html"/>
      <url>/posts/46616.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题链接：https-www-dotcpp-com-oj-problem2085-html"><a href="#问题链接：https-www-dotcpp-com-oj-problem2085-html" class="headerlink" title="问题链接：https://www.dotcpp.com/oj/problem2085.html"></a>问题链接：<a href="https://www.dotcpp.com/oj/problem2085.html">https://www.dotcpp.com/oj/problem2085.html</a></h3><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>作为一名网络警察，你的任务是监视电子邮件，看其中是否有一些敏感的关键词。不过，有些狡猾的犯罪嫌疑人会改变某些单词的字母顺序，以逃避检查。请编写一个程序，发现这种调整过顺序的关键词。程序的输入有两行，第一行是关键词列表，第二行是待检查的句子。程序的输出为在该句子中所找到的经过顺序调整的关键词。（单词全部为小写，单词之间以一个空格分隔，每一行的单词个数不限）</p><h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><h3 id="guns-mines-missiles"><a href="#guns-mines-missiles" class="headerlink" title="guns mines missiles"></a>guns mines missiles</h3><h3 id="aameric-ssell-snug-dan-iimsssle-ot-sit-neeemis"><a href="#aameric-ssell-snug-dan-iimsssle-ot-sit-neeemis" class="headerlink" title="aameric ssell snug dan iimsssle ot sit neeemis"></a>aameric ssell snug dan iimsssle ot sit neeemis</h3><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><h3 id="guns-missiles"><a href="#guns-missiles" class="headerlink" title="guns missiles"></a>guns missiles</h3><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>废物的我看到这题想着好麻烦，想着用for循环把每个字符串从输入提取出来然后再一一对比，感觉会死。但是我发现了大佬的写法，越发觉得stl真无敌，顺便学会了istringstream的用法。</p><h4 id="下面是istringstream用法的举例"><a href="#下面是istringstream用法的举例" class="headerlink" title="下面是istringstream用法的举例"></a>下面是istringstream用法的举例</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits/stdc++.h&gt; using namespace std;   int main()    {      string str = "aa bb cc dd ee";      istringstream is(str);//创建istringstream对象is     //并同时使is和字符串str绑定     string s;       while (is &gt;&gt; s)//将从str中读取到的字符串is写入到字符串s    {          cout &lt;&lt; s &lt;&lt; endl;      }        return 0; } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">输出如下:aamericssellsnugdaniimsssleotsitneeemis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好，接下来说思路，那有了istringstream这样的利器就好写了,拿两个字符串进行输入，然后再用vector存放提取出来的字符串，同时把每个字符串sort一下，这样比较就只要简单的==就行了。</p><h3 id="下面是源代码："><a href="#下面是源代码：" class="headerlink" title="下面是源代码："></a>下面是源代码：</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    string str1,str2;    getline(cin, str1);    getline(cin, str2);    vector&lt;string&gt;s1,s2,s3;    istringstream Str1(str1),Str2(str2);    string temp;    while(Str1&gt;&gt;temp) {        s1.push_back(temp);        s2.push_back(temp);    }    while (Str2&gt;&gt;temp) {        s3.push_back(temp);    }    for (int i = 0; i &lt; s3.size(); i++) {        sort(s3[i].begin(),s3[i].end());    }    for (int i = 0; i &lt; s3.size(); i++) {        for (int j = 0; j&lt;s2.size(); j++) {            sort(s2[j].begin(),s2[j].end());if (s3[i] == s2[j]) {                cout &lt;&lt; s1[j] &lt;&lt;" ";                break;             }        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费馅饼（dp入门）</title>
      <link href="/posts/20518.html"/>
      <url>/posts/20518.html</url>
      
        <content type="html"><![CDATA[<h2 id="免费馅饼"><a href="#免费馅饼" class="headerlink" title="免费馅饼"></a>免费馅饼</h2><p>问题描述：</p><h5 id="都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标："><a href="#都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：" class="headerlink" title="都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标："></a>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：</h5><p><img src="/posts/20518/1.png"></p><h5 id="为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）"><a href="#为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）" class="headerlink" title="为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）"></a>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</h5><pre class="line-numbers language-none"><code class="language-none">Input输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。Output每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Sample Input65 14 16 17 27 28 30Sample Output4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://vjudge.net/problem/HDU-1176">https://vjudge.net/problem/HDU-1176</a></p><h4 id="这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。"><a href="#这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。" class="headerlink" title="这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。"></a>这题其实和数塔问题很像，只不过这个不像数塔问题那么直接，这个相当与变种的数塔问题，那我们要如何把它转化成数塔问题呢？其实我们可以把每一秒作为每一层，比如第零秒的馅饼做一层，第一秒的馅饼做第二层以此类推。</h4><h4 id="下面是对样例的数组a-以及dp的展现"><a href="#下面是对样例的数组a-以及dp的展现" class="headerlink" title="下面是对样例的数组a,以及dp的展现"></a>下面是对样例的数组a,以及dp的展现</h4><pre class="line-numbers language-none"><code class="language-none">a[i][j]0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 1 1 1 0 0 00 0 0 0 0 0 0 0 2 0 00 0 0 0 0 0 0 0 0 1 0dp[i][j]0 0 0 0 1 1 4 4 4 3 30 0 0 0 0 1 1 4 3 3 10 0 0 0 0 0 0 0 3 1 10 0 0 0 0 0 0 0 0 1 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="由此得出状态转换方程dp-i-j-max-dp-i-1-j-1-max-dp-i-1-j-dp-i-1-j-1-a-i-j"><a href="#由此得出状态转换方程dp-i-j-max-dp-i-1-j-1-max-dp-i-1-j-dp-i-1-j-1-a-i-j" class="headerlink" title="由此得出状态转换方程dp[i][j]=max(dp[i+1][j-1], max(dp[i+1][j],dp[i+1][j+1]))+ a[i][j];"></a>由此得出状态转换方程dp[i][j]=max(dp[i+1][j-1], max(dp[i+1][j],dp[i+1][j+1]))+ a[i][j];</h4><h4 id="ps-位置从0开始不是很好处理，所以把每个位置就加一，从一开始"><a href="#ps-位置从0开始不是很好处理，所以把每个位置就加一，从一开始" class="headerlink" title="ps:位置从0开始不是很好处理，所以把每个位置就加一，从一开始"></a>ps:位置从0开始不是很好处理，所以把每个位置就加一，从一开始</h4><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int manx=1e5+5;int dp[manx][15];//num[a][b]代表第a秒在b位置上馅饼的数量 int a[manx][15];//dp[a][b]代表第a秒在b位置上做多能有多少馅饼int n;int main(){    while(scanf("%d",&amp;n)!=EOF)    {        if(!n) break;        memset(dp,0,sizeof(dp));        memset(a,0,sizeof(a));        int e=0;        for(int i=1;i&lt;=n;i++){            int x,t;            scanf("%d%d",&amp;x,&amp;t);            a[t][++x]++;//统计在b秒时位置x的馅饼数             e=max(e,t);//确定层数 }        }        for(int i=e;i&gt;=0;i--)        {        for(int j=1;j&lt;=11;j++)        {        dp[i][j]=max(dp[i+1][j-1],                    max(dp[i+1][j],dp[i+1][j+1]))+                    a[i][j];}}        cout&lt;&lt;dp[0][6]&lt;&lt;endl;     }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走迷宫（bfs)</title>
      <link href="/posts/29413.html"/>
      <url>/posts/29413.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。</p><p>最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p><p>请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。</p><p>数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。</p><p>输入格式<br>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。</p><p>输出格式<br>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><p>数据范围<br>1≤n,m≤100</p><h1 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h1><h1 id="5-5"><a href="#5-5" class="headerlink" title="5 5"></a>5 5</h1><h1 id="0-1-0-0-0"><a href="#0-1-0-0-0" class="headerlink" title="0 1 0 0 0"></a>0 1 0 0 0</h1><h1 id="0-1-0-1-0"><a href="#0-1-0-1-0" class="headerlink" title="0 1 0 1 0"></a>0 1 0 1 0</h1><h1 id="0-0-0-0-0"><a href="#0-0-0-0-0" class="headerlink" title="0 0 0 0 0"></a>0 0 0 0 0</h1><h1 id="0-1-1-1-0"><a href="#0-1-1-1-0" class="headerlink" title="0 1 1 1 0"></a>0 1 1 1 0</h1><h1 id="0-0-0-1-0"><a href="#0-0-0-1-0" class="headerlink" title="0 0 0 1 0"></a>0 0 0 1 0</h1><h1 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h1><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;int dx[]={0,0,-1,1};int dy[]={-1,1,0,0};int mp[110][110];int vis[110][110];struct node{    int x,y,step;};bool cheak(int x,int y){if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m&amp;&amp;y&gt;=1&amp;&amp;!vis[x][y]&amp;&amp;mp[x][y]!=1)return true;else return false;}void bfs(){    queue&lt;node&gt;q;    node now,next;    now.x=now.y=1;now.step=0;    vis[1][1]=1;    q.push(now); while(!q.empty()){    now=q.front();q.pop();if(now.x==n&amp;&amp;now.y==m){     cout&lt;&lt;now.step&lt;&lt;endl; return;    }for(int i=0;i&lt;4;i++){    next.x=now.x+dx[i];next.y=now.y+dy[i];next.step=now.step+1;if(cheak(next.x,next.y)){vis[next.x][next.y]=1;q.push(next);}}} }int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++ )      {          for (int j = 1; j &lt;= m; j ++ )          {              cin &gt;&gt; mp[i][j];          }      }      bfs();      return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="思路后续更新"><a href="#思路后续更新" class="headerlink" title="思路后续更新"></a>思路后续更新</h1>]]></content>
      
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪吃蛇</title>
      <link href="/posts/17402.html"/>
      <url>/posts/17402.html</url>
      
        <content type="html"><![CDATA[<h1 id="贪吃蛇c"><a href="#贪吃蛇c" class="headerlink" title="贪吃蛇c++"></a>贪吃蛇c++</h1><h1 id="注意需要安装easy库函数"><a href="#注意需要安装easy库函数" class="headerlink" title="注意需要安装easy库函数"></a><strong>注意需要安装easy库函数</strong></h1><h2 id="这是我第一次尝试做，可能比较拉（比如暂停功能有bug之-doge-，🐍有点简陋。。。）"><a href="#这是我第一次尝试做，可能比较拉（比如暂停功能有bug之-doge-，🐍有点简陋。。。）" class="headerlink" title="这是我第一次尝试做，可能比较拉（比如暂停功能有bug之[doge]，🐍有点简陋。。。）"></a><del>这是我第一次尝试做，可能比较拉（比如暂停功能有bug之[doge]，🐍有点简陋。。。）</del></h2><h3 id="下面是源代码"><a href="#下面是源代码" class="headerlink" title="下面是源代码"></a>下面是源代码</h3><pre class="line-numbers language-#include<stdio.h>" data-language="#include<stdio.h>"><code class="language-#include<stdio.h>">#include&lt;easyx.h&gt;#include &lt;conio.h&gt;//按键操作#include&lt;stdlib.h&gt;#include&lt;graphics.h&gt;//1.同下#include&lt;mmsyscom.h&gt;//2.同下#pragma comment(lib,"winmm.lib")//3.多媒体#define Coords 500#define length 700#define high   500int cnt=0;char num[20];bool isplay;enum DIR//枚举，但不知道怎么用的{ up,   down,   left,   right,};struct snake//蛇的结构{  int size;//蛇的字节  int dir;//蛇的方向  int speed;//移动速度  POINT coor[Coords];//坐标}snake;struct food{int x;int y;int r;bool flag;//判定是否被吃DWORD color;}food;void loadrescource(){IMAGE background;//定义一个图片名.loadimage(&amp;background, "./picture1/true.jfif",700,500);//从图片文件获取图像putimage(0, 0, &amp;background);//绘制图像到屏幕，图片左上角坐标为(0,0)}void gameinit()//初始化{isplay = true;mciSendString("open ./music/7895.mp3 alias bgm", 0, 0, 0);mciSendString("play bgm repeat", 0, 0, 0);//init初始化 graph 图形窗口initgraph(length,high);srand(GetTickCount());//随机数种子//设时间为随机数,获取系统开机到现在的毫秒数//初始化蛇，一开始3节snake.size = 3;     snake.speed =5;snake.dir=right;//方向for (int i = 0; i &lt;snake.size; i++) {snake.coor[i].x = 70-15*i;    snake.coor[i].y = 10;}//初始化食物food.x = rand() % (length-100)+25;//随机产生一个整数的函数，需要随机数种子food.y = rand() % (high - 100)+25;food.color = RGB(rand()%256,rand()%256,rand()%256);food.r = rand() % 10 +10;food.flag = true;}void gamedraw()//绘制蛇{//sprintf(Time,"%d",pp);BeginBatchDraw();//双缓存//setbkcolor(RGB(28, 115, 119));cleardevice();//清空绘图设备loadrescource();outtextxy(610, 10, "分数:");outtextxy(650, 10, num);outtextxy(540, 10, "音乐:");if (isplay){         outtextxy(585, 10, "开");}else{outtextxy(585, 10, "关");}setfillcolor(BLUE);//设置蛇身颜色为蓝色for (int i = 1; i &lt;snake.size; i++) {solidcircle(snake.coor[i].x, snake.coor[i].y, 6);//x轴，y轴，半径}setfillcolor(RED);//设置蛇头颜色为红色solidcircle(snake.coor[0].x, snake.coor[0].y, 6);if (food.flag==true){solidcircle(food.x, food.y, food.r);}EndBatchDraw();}void snakemove() {//移动蛇for (int i = snake.size-1; i &gt;0; i--)//后面到前面依次向前走{snake.coor[i]=snake.coor[i - 1]; }switch (snake.dir){case up://进行方向改变snake.coor[0].y-=snake.speed;if (snake.coor[0].y +6&lt;= 0) {snake.coor[0].y = high;}break;case down://同上snake.coor[0].y+=snake.speed;if (snake.coor[0].y + 6 &gt;= high){snake.coor[0].y = 0;}break;case left://同上snake.coor[0].x-=snake.speed;if (snake.coor[0].x + 6 &lt;= 0){snake.coor[0].x = length;}break;case right://同上snake.coor[0].x+=snake.speed;if (snake.coor[0].x+ 6 &gt;=length){snake.coor[0].x = 0;}break;}}void keycontrol(){//通过按键进行控制if (_kbhit())//判断有没有按键，如果有就为真{    switch (_getch())  {//72 80 75 77 上下左右键值 case 'w':case 'W':case 72:if (snake.dir != down) {                     snake.dir = up;}//改变方向break;case 's':case 'S':case 80:if (snake.dir != up){   snake.dir = down;}break;case 'a':case 'A':case 75:if (snake.dir != right){snake.dir = left;}break;case 'd':case 'D':case 77:if (snake.dir != left){snake.dir = right;}break;case ' ':   //按空格暂停if (isplay){mciSendString("pause  bgm", 0, 0, 0);isplay = !isplay;outtextxy(585, 10, "关");}else{mciSendString("play  bgm repeat", 0, 0, 0);isplay = !isplay;outtextxy(585, 10, "开");}while (1){if (_getch() == ' '){outtextxy(585, 10, "开");return;}}     }}}void eatfood(){sprintf(num,"%d",cnt);if (food.flag == true &amp;&amp; snake.coor[0].x &gt;= food.x - food.r &amp;&amp; snake.coor[0].x &lt;= food.x + food.r&amp;&amp; snake.coor[0].y &gt;= food.y - food.r &amp;&amp; snake.coor[0].y &lt;= food.y + food.r){//判断吃到食物food.flag = false;snake.size++;//snake.speed++;if (food.r&gt;=8){        cnt+=1;}else if (food.r &lt; 8){cnt += 2;}}if (food.flag == false)//刷新食物{food.x = rand() % length;//随机产生一个整数的函数，需要随机数种子food.y = rand() % high;food.color = RGB(rand() % 256, rand() % 256, rand() % 256);food.r = rand() % 10 + 5;food.flag = true;}}void cheak()//吃到自己死亡{for (int i = 1; i &lt; snake.size; i++){if (snake.coor[0].x == snake.coor[i].x &amp;&amp;snake.coor[0].y == snake.coor[i].y){gameinit();cnt = 0;}}}int main(){gameinit();while (1) {   gamedraw();  snakemove();  keycontrol();  eatfood();  Sleep(20);//延迟20毫秒  cheak();}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="到此为止，感想大家观看"><a href="#到此为止，感想大家观看" class="headerlink" title="到此为止，感想大家观看"></a>到此为止，感想大家观看</h2><h2 id="ps-刚搭的博客，还没搞好，先凑合用"><a href="#ps-刚搭的博客，还没搞好，先凑合用" class="headerlink" title="ps:刚搭的博客，还没搞好，先凑合用"></a><del>ps:刚搭的博客，还没搞好，先凑合用</del></h2><p>此代码仅供参考，帮助大家理解。（毕竟我自己开始弄的时候什么都看不懂，花了好久才会的，希望这个能帮助大家）</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
